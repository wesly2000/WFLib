"""
A module for website browsing and traffic capture. Ideally, they should work coorperatively
in an asynchronized style. The general workflow is as follows.

main        ----------------------------------------------------------------------------------------------------->
                         |      |                                                           ^       ^
browsing                 |      v-----------------------------------------------------------|       |
                         |                                                                          |
sniff                    v---------------------------------------------------------------------------
                         |                                                                          |
capture                  |--------------------------------------------------------------------------|
"""

from selenium import webdriver
from selenium.webdriver.firefox.options import Options
from selenium.webdriver.firefox.service import Service

from scapy.all import sniff, wrpcap
import pyshark
from pyshark.capture.capture import Capture

import time
import threading

gecko_path = r'/usr/local/bin/geckodriver'

"""
This filter is a Capture Filter to filter the annoying traffic which, with high probability, is NOT related with the
traffic directly generated by requesting the website. Although some protocols DO relate to surfing the Web, e.h., SOAP and DNS,
they do NOT belong to the communication process between the client and server. Therefore, they are NOT included in
the capture.

The semantics of the filter is that we ONLY want TCP or UDP packets, but the following protocols are NOT considered:

LLMNR (5355), MDNS (5353), SOAP (3702), NTP (123), SSDP (1900), SSH (22), RDP (3389), DOT (853), HTTP (80)

NOTE: This filter is not exhausted, and further updates are possible in the future.
NOTE: Plain HTTP (port 80) is excluded after some consideration, since most of the request are based on HTTPS 
"""
common_filter = 'not (port 53 or port 22 or port 3389 or port 5355 or port 5353 or port 3702 or port 123 or port 1900 or port 853 or port 80) and (tcp or udp)'

def capture(url, timeout, iface, output_file, log_output=None):
    stop_event = threading.Event()

    def _sniff(iface, output_file):
        print("Capturing Starts.......................")
        capture = sniff(iface=iface, filter=common_filter, stop_filter=lambda _: stop_event.is_set())
        wrpcap(output_file, capture)
        print("Capturing Ends.......................")

    def browse(url, timeout, log_output=None):
        time.sleep(1) # maybe waiting for interface to be ready?
        service = Service(executable_path=gecko_path, log_output=log_output)

        options = Options()
        options.add_argument("--headless") 
        options.set_preference("browser.cache.disk.enable", False)
        options.set_preference("browser.cache.memory.enable", False)
        options.set_preference("browser.cache.offline.enable", False)
        options.set_preference("network.http.use-cache", False)

        driver = webdriver.Firefox(options=options, service=service)
        print("Browsing Starts.......................")
        driver.get(url)
        time.sleep(timeout)
        # Notify the capture thread that the capturing process is over.
        stop_event.set()
        driver.quit()
        print("Browsing Ends.......................")

    browse_thread = threading.Thread(target=browse, kwargs={"url": url, "timeout": timeout})
    capture_thread = threading.Thread(target=_sniff, kwargs={"iface": iface, "output_file": output_file})

    capture_thread.start()
    browse_thread.start()

    browse_thread.join()
    capture_thread.join()

def SNI_extract(capture : Capture) -> set:
    """
    Extract all SNIs from a capture, and return a set that contains these SNIs.
    """
    SNIs = set()

    def process_packet(packet):
        try:
            if 'TLS' in packet:
                tls_layer = packet['TLS']
                if hasattr(tls_layer, 'handshake_extensions_server_name'):
                    SNI = tls_layer.handshake_extensions_server_name
                    SNIs.add(SNI)
        except AttributeError as e:
            # Handle packets that don't have the expected structure
            print(f"Error processing packet: {e}")

    for pkt in capture:
        process_packet(pkt)
    return SNIs

def stream_number_extract(capture : Capture, check) -> set:
    """
    Extract all TCP stream numbers for the streams where at least one packet within satisfies
    the condition required by the check.

    For example, if the check checks whether a TLS session is for SNI=www.baidu.com, it iterates
    over all the packets (all Client Hello's actually), if some packet contains the SNI, the tcp.stream
    numbers will be recorded.

    TODO: Currently, the extractor only works for TCP-based protocols. Integrating the support for UDP will
    be finished in the future. :)

    Parameter
    ---------
    check : function(pkt) -> bool
        The check on packet. Return TRUE if the packet satisfies the condition.

    Return
    ------
    set : The set contains the stream numbers each of which contains at least 1 packet satisfying check.
    """
    stream_numbers = set(pkt['TCP'].stream for pkt in capture if check(pkt))
    return stream_numbers

def stream_extract(input_file : str, stream_numbers : list|set, output_file : str):
    """
    Extract the streams with the given stream_numbers from input_file, and write the results to output_file.
    """
    pass